//1106 --- DAY1
- 1.int *p[4] 与选择项中的 说明 （C） 等价    //错误选择了D

A int p[4]

B int *p

C int *(p[4])

D int (*p)[4]

```
    D是数组指针而C与题目都为指针数组
```

- 2.在 c++ 语言中，对函数参数默认值描述正确的是（D）  //错误选择了B

A 函数参数的默认值只能设定一个

B 一个函数的参数若有多个，则参数默认值的设定可以不连续

C 函数参数必须设定默认值

D 在设定了参数的默认值后，该参数后面定义的所有参数都必须设定默认值


```
对于B：参数默认值必须从右向左定义，即在一个指定了默认值的参数的右边，不能出现没有指定默认值的参数。
```

// 1107 --- DAY2

- 3.下面叙述错误的是（D）    //错误选择了C

```cpp
    char acX[] = "abc";
    char acY[] = {'a','b','c'};
    char *szX = "abc";
    char *szY = "abc"; 
```
A acX与acY的内容可以修改

B szX与szY指向同一个地方

C acX占用的内存空间比acY大

D szX内容修改后，szY内容也会被修改

```
    acX与acY所占空间大小是一样的
```

- 4.在32位cpu上选择缺省对齐的情况下，有如下结构体定义：

```c
    struct A{
        unsigned a:19;
        unsigned b:11;
        unsigned c:4;
        unsigned d:29;
        char index;
    };
```
则sizeof(struct A)的值是（C）     //错误选择了D

A 9

B 12

C 16

D 20

- 5.以下关于C++的描述中哪一个是正确的（C）    //错误选择了D

A 任何指针都必须指向一个实例

B 子类指针不可以指向父类实例

C 任何引用都必须指向一个实例

D 引用所指向的实例不可能无效

- 6.关于虚函数描述正确的是（B）  //错误选择了C

A 派生类的虚函数与基类的虚函数具有不同的参数个数和类型

B 内联函数不能是虚函数

C 派生类必须重新定义基类的虚函数

D 虚函数可以是一个static型的函数

```        
    inline是在编译器将函数类容替换到函数调用处，是静态编译的。
    而虚函数是动态调用的，在编译器并不知道需要调用的是父类还是子类的虚函数，
    所以不能够inline声明展开，所以编译器会忽略

    虚函数的调用必须有this指针，而static型函数没有this指针。

```

- 7.关于C++的inline关键字，以下说法正确的是（D）   //错误选择了C

A 使用inline关键字的函数会被编译器在调用处展开

B 头文件中可以包含inline函数的声明

C 可以在同一个项目的不同源文件内定义函数名相同但实现不同的inline函数

D 定义在class声明内的成员函数默认是inline函数

E 优先使用class声明内定义的inline函数

F 优先使用class实现的inline函数的实现

//1108 --- DAY3

- 8.能把函数处理结果的第二个数据返回给主调函数，在下面的方法中不正确的是（A）   //错误选择了D

A return这二个数

B 形参用数组

C 形参用二个指针

D 用二个局部变量

- 9.由多个源文件组成的C程序，经过编辑、预处理、编译、链接阶段会生成最终的可执行程序。下面哪个阶段可以发现被调用的函数未定义？
    C  //错误选择了A

A 预处理

B 编译

C 链接

D 执行

```


链接是将各个编译单元中的变量和函数引用与定义进行绑定，保证程序中的变量和函数都有对应的实体，
若被调用函数未定义，就在此过程中会发现。
编辑阶段创建和修改源程序,预处理阶段分析宏定义以及替换宏引用；编译过程是把源程序翻译为与之等价的目标程序。
```

- 10.下列main()函数执行后的结果为(B)    //错误选择了C
```cpp
    int func()
    {
        int i,j,k = 0;
        for(i = 0; j = -1;j = 0;i++,j++){
            k++;
        }
        return k;
    }
    int main()
    {
        cout << (func());
    }
```
A -1

B 0

C 1

D 2

```
    注意第一次j不满足条件后，函数跳出循环及直接return k；
```
// 1109 --- DAY4

- 11.以下C语言指令：
```c
以下C语言指令：运行结果是什么？（C）   //错误选择了D
int a[5] = {1,3,5,7,9};
int *p = (int *)(&a+1);
printf(“%d,%d”,*(a+1)，*(p-1));
```
A 2，1

B 3，1

C 3，9

D 运行时崩溃

```
    这里&a，取的是整个数组的地址，所以p最终指向数组的下一个位置
```

- 12.以下关于纯虚函数的说法,正确的是(A)     //错误选择了C

A 声明纯虚函数的类不能实例化

B 声明纯虚函数的类成虚基类

C 子类必须实现基类的

D 纯虚函数必须是空函数

```
    纯虚函数在基类中是没有定义的，必须在子类中加以实现
    基类被虚继承才是虚基类 
```

- 13.下列情况中，不会调用拷贝构造函数的是（B） //错误选择了D

A 用一个对象去初始化同一个类的另一个新对象时

B 将类的一个对象赋值给该类的另一个对象时

C 函数的形参对象，调用函数进行形参和实参结合时

D 函数的返回值是类的对象，函数执行返回调用时


```
    对于B选项，要赋值的对象是已经存在的，所以不需要调用拷贝构造函数
```


// 1110 --- DAY5

- 13.下面两个结构体

```c    
struct One{
    double d;
    char c;
    int i;
}
struct Two{
    char c;
    double d;
    int i;
}

```
在#pragma pack(4)和#pragma pack(8)的情况下，结构体的大小分别是(C)    //错误选择了B
A 16 24,16 24
B 16 20,16 20
C 16 16,16 24
D 16 16,24 24

- 14.下面程序的输出结果是(B)       //错误选择了A

```c
#include<iosteam.h>
void main(){
    int n[][3] = {10,20,30,40,50,60};
    int (*p)[3];
    p=n;
    cout<<p[0][0]<<","<<*(p[0]+1)<<","<<(*p)[2]<<endl;
}

```
A 10,30,50

B 10,20,30

C 20,40,60

D 10,30,60


- 15.
```c
int main(){
    int a;float b,c;
    scanf("%2d%3f%4f",&a,&b,&c);
    printf("\na=%d,b=%d,c=%f\n",a,b,c);
}
```
若运行时从键盘上输入9876543210l,则上面程序在gcc编译器下的输出结果是(B)    //错误选择了C

A a=98,b=765,c=4321.000000

B a=98,b=0,c=0.000000

C a=98,b=765.000000,c=4321.000000

D a=98,b=765.0,c=4321.0

- 16.
```c
ClassA *pclassa=new ClassA[5];
delete pclassa;
```
c++语言中，类ClassA的构造函数和析构函数的执行次数分别为(A)      //错误选择了C

A 5,1

B 1,1

C 5,5

D 1,5

```
    这里delete的是指针不是指向的数组
```

// 1111  --- DAY6

- 17.
```c
#include<iostream>
#include<stdio.h>
using namespace std;
int main(){
int m=0123, n = 123;
printf("%o %o\n", m, n);
return 0;
}
```
程序运行后的输出结果是(C)     //错误选择了D

A 0123 0173

B 0123 173

C 123 173

D 173 173

```
    %o 是以八进制输出  所以0123 --- 1*（8 ^ 2） + 2 * 8 + 3 * 1 = 123
```

- 18.关于"深拷贝"，下列说法正确的是(A)   //错误选择了D

A 会拷贝成员数据的值和会拷贝静态分配的成员对象

B 只会拷贝成员数据的值

C 只会拷贝静态分配的成员对象

D 只会拷贝动态分配的成员对象

```
    深拷贝是新建一个对象，把原来对象的数据复制过来。
    但是有一点要注意，对含有静态成员数据的对象，
    静态成员属于类，被所有对象共享，所以深拷贝也不会拷贝这一份数据。只会拷贝非静态成员数据
```