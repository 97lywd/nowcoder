//1106 --- DAY1
- 1.int *p[4] 与选择项中的 说明 （C） 等价    //错误选择了D

A int p[4]

B int *p

C int *(p[4])

D int (*p)[4]

```
    D是数组指针而C与题目都为指针数组
```

- 2.在 c++ 语言中，对函数参数默认值描述正确的是（D）  //错误选择了B

A 函数参数的默认值只能设定一个

B 一个函数的参数若有多个，则参数默认值的设定可以不连续

C 函数参数必须设定默认值

D 在设定了参数的默认值后，该参数后面定义的所有参数都必须设定默认值


```
对于B：参数默认值必须从右向左定义，即在一个指定了默认值的参数的右边，不能出现没有指定默认值的参数。
```

// 1107 --- DAY2

- 3.下面叙述错误的是（D）    //错误选择了C

```cpp
    char acX[] = "abc";
    char acY[] = {'a','b','c'};
    char *szX = "abc";
    char *szY = "abc"; 
```
A acX与acY的内容可以修改

B szX与szY指向同一个地方

C acX占用的内存空间比acY大

D szX内容修改后，szY内容也会被修改

```
    acX与acY所占空间大小是一样的
```

- 4.在32位cpu上选择缺省对齐的情况下，有如下结构体定义：

```c
    struct A{
        unsigned a:19;
        unsigned b:11;
        unsigned c:4;
        unsigned d:29;
        char index;
    };
```
则sizeof(struct A)的值是（C）     //错误选择了D

A 9

B 12

C 16

D 20

- 5.以下关于C++的描述中哪一个是正确的（C）    //错误选择了D

A 任何指针都必须指向一个实例

B 子类指针不可以指向父类实例

C 任何引用都必须指向一个实例

D 引用所指向的实例不可能无效

- 6.关于虚函数描述正确的是（B）  //错误选择了C

A 派生类的虚函数与基类的虚函数具有不同的参数个数和类型

B 内联函数不能是虚函数

C 派生类必须重新定义基类的虚函数

D 虚函数可以是一个static型的函数

```        
    inline是在编译器将函数类容替换到函数调用处，是静态编译的。
    而虚函数是动态调用的，在编译器并不知道需要调用的是父类还是子类的虚函数，
    所以不能够inline声明展开，所以编译器会忽略

    虚函数的调用必须有this指针，而static型函数没有this指针。

```

- 7.关于C++的inline关键字，以下说法正确的是（D）   //错误选择了C

A 使用inline关键字的函数会被编译器在调用处展开

B 头文件中可以包含inline函数的声明

C 可以在同一个项目的不同源文件内定义函数名相同但实现不同的inline函数

D 定义在class声明内的成员函数默认是inline函数

E 优先使用class声明内定义的inline函数

F 优先使用class实现的inline函数的实现

//1108 --- DAY3

- 8.能把函数处理结果的第二个数据返回给主调函数，在下面的方法中不正确的是（A）   //错误选择了D

A return这二个数

B 形参用数组

C 形参用二个指针

D 用二个局部变量

- 9.由多个源文件组成的C程序，经过编辑、预处理、编译、链接阶段会生成最终的可执行程序。下面哪个阶段可以发现被调用的函数未定义？
    C  //错误选择了A

A 预处理

B 编译

C 链接

D 执行

```


链接是将各个编译单元中的变量和函数引用与定义进行绑定，保证程序中的变量和函数都有对应的实体，
若被调用函数未定义，就在此过程中会发现。
编辑阶段创建和修改源程序,预处理阶段分析宏定义以及替换宏引用；编译过程是把源程序翻译为与之等价的目标程序。
```

- 10.下列main()函数执行后的结果为(B)    //错误选择了C
```cpp
    int func()
    {
        int i,j,k = 0;
        for(i = 0; j = -1;j = 0;i++,j++){
            k++;
        }
        return k;
    }
    int main()
    {
        cout << (func());
    }
```
A -1

B 0

C 1

D 2

```
    注意第一次j不满足条件后，函数跳出循环及直接return k；
```
// 1109 --- DAY4

- 11.以下C语言指令：
```c
以下C语言指令：运行结果是什么？（C）   //错误选择了D
int a[5] = {1,3,5,7,9};
int *p = (int *)(&a+1);
printf(“%d,%d”,*(a+1)，*(p-1));
```
A 2，1

B 3，1

C 3，9

D 运行时崩溃

```
    这里&a，取的是整个数组的地址，所以p最终指向数组的下一个位置
```

- 12.以下关于纯虚函数的说法,正确的是(A)     //错误选择了C

A 声明纯虚函数的类不能实例化

B 声明纯虚函数的类成虚基类

C 子类必须实现基类的

D 纯虚函数必须是空函数

```
    纯虚函数在基类中是没有定义的，必须在子类中加以实现
    基类被虚继承才是虚基类 
```

- 13.下列情况中，不会调用拷贝构造函数的是（B） //错误选择了D

A 用一个对象去初始化同一个类的另一个新对象时

B 将类的一个对象赋值给该类的另一个对象时

C 函数的形参对象，调用函数进行形参和实参结合时

D 函数的返回值是类的对象，函数执行返回调用时


```
    对于B选项，要赋值的对象是已经存在的，所以不需要调用拷贝构造函数
```


// 1110 --- DAY5

- 14.下面两个结构体

```c    
struct One{
    double d;
    char c;
    int i;
}
struct Two{
    char c;
    double d;
    int i;
}

```
在#pragma pack(4)和#pragma pack(8)的情况下，结构体的大小分别是(C)    //错误选择了B
A 16 24,16 24
B 16 20,16 20
C 16 16,16 24
D 16 16,24 24

- 15.下面程序的输出结果是(B)       //错误选择了A

```c
#include<iosteam.h>
void main(){
    int n[][3] = {10,20,30,40,50,60};
    int (*p)[3];
    p=n;
    cout<<p[0][0]<<","<<*(p[0]+1)<<","<<(*p)[2]<<endl;
}

```
A 10,30,50

B 10,20,30

C 20,40,60

D 10,30,60


- 16.
```c
int main(){
    int a;float b,c;
    scanf("%2d%3f%4f",&a,&b,&c);
    printf("\na=%d,b=%d,c=%f\n",a,b,c);
}
```
若运行时从键盘上输入9876543210l,则上面程序在gcc编译器下的输出结果是(B)    //错误选择了C

A a=98,b=765,c=4321.000000

B a=98,b=0,c=0.000000

C a=98,b=765.000000,c=4321.000000

D a=98,b=765.0,c=4321.0

- 17.
```c
ClassA *pclassa=new ClassA[5];
delete pclassa;
```
c++语言中，类ClassA的构造函数和析构函数的执行次数分别为(A)      //错误选择了C

A 5,1

B 1,1

C 5,5

D 1,5

```
    这里delete的是指针不是指向的数组
```

// 1111  --- DAY6

- 18.
```c
#include<iostream>
#include<stdio.h>
using namespace std;
int main(){
int m=0123, n = 123;
printf("%o %o\n", m, n);
return 0;
}
```
程序运行后的输出结果是(C)     //错误选择了D

A 0123 0173

B 0123 173

C 123 173

D 173 173

```
    %o 是以八进制输出  所以0123 --- 1*（8 ^ 2） + 2 * 8 + 3 * 1 = 123
```

- 19.关于"深拷贝"，下列说法正确的是(A)   //错误选择了D

A 会拷贝成员数据的值和会拷贝静态分配的成员对象

B 只会拷贝成员数据的值

C 只会拷贝静态分配的成员对象

D 只会拷贝动态分配的成员对象

```
    深拷贝是新建一个对象，把原来对象的数据复制过来。
    但是有一点要注意，对含有静态成员数据的对象，
    静态成员属于类，被所有对象共享，所以深拷贝也不会拷贝这一份数据。只会拷贝非静态成员数据
```


// 1113 DAY7

- 20.有如下类模板定义：（D）   //错误选择了B
```cpp
template<class T> class BigNumber{
    long n;
public:
    BigNumber(T i):n(i){}
    BigNumber operator+(BigNumber b)
        {
            return BigNumber(n+b.n);
        }
};
```
A 3+3

B b1+3

C b1+b2

D 3+b1

- 21. 在int p[][4]={{1},{3,2},{4,5,6},{0}};中，p[1][2]的值是(B)   //错误选择了D

A 1

B 0

C 6

D 2

- 22.下列关于对象数组的描述中，(A)是错误的   //错误选择了C

A 对象数组只能赋初值而不能再赋值

B 对象数组的每个元素是同一个类的对象

C 对象数组的数组名是一个指针常量

D 对象数组的下标是从0开始的

```
    指针常量：强调的是一个指针指向了一个常量，所以地址是不可变的，但是内容是可以修改的，这和数组名相符
```


// 1114 DAY8
- 23.下面关于"指针"的描述不正确的是(A)     //错误选择了D
A 当使用free释放掉一个指针内容后,指针变量的值被置为NULL

B 32位系统下任何类型指针的长度都是4个字节

C 指针的数据类型声明的是指针实际指向内容的数据类型

D 野指针是指向未分配或者已经释放的内存地址

```
    当free释放内存之后，指针还指向原来的那块地址，需要我们设置 p= NULL；
    如果不手动设置p = NULL，此时P就变成了野指针
    野指针：指向一个已删除的对象或未申请访问受限内存区域的指针（如未初始化或者free后没有置为NULL）
```

- 24.假定有类AB，有相应的构造函数定义，能正确执行
语句，请问执行完此语句后共调用该类的构造函数次数为__(A)  //错误选择了D

` AB a(4),b(5),c[3],*p[2]={&a,&b};

A 5

B 4

C 3

D 9

// 1115 DAY9
- 25.当一个类的某个函数被说明为virtual，则在该类的所有派生类中的同原型函数（D）//错误选择了A

A 只有被重新说明时才是虚函数

B 只有被重新说明为virtual时才是虚函数

C 都不是虚函数

D 都是虚函数

```
    派生类继承父类虚函数后，保留其虚函数性质，所以重写时加不加vtrtual关键字，都是虚函数
    但是为了代码规范，一般加virtual
```

// 1116 DAY10

- 26.有如下C++代码：

``` cpp
struct A{
    void foo(){printf("foo");}
    virtual void bar(){printf("bar");}
    A(){bar();}
};
struct B:A{
    void foo(){printf("b_foo");}
    void bar(){printf("b_bar");}
};
那么
A *p=new B;
p->foo();
p->bar();
```
输出为：（A）   //错误选择了B
A barfoob_bar

B foobarb_bar

C barfoob_foo

D foobarb_fpp

```
    这里A调用foo时，foo不是虚函数，所以调用的是A::foo(),而bar不是虚函数,所以调用的是B::bar()
```

- 27.代码可以通过编译吗？如果不能应该如何修改？(D)  //错误选择了A
```cpp
    template<class T> class Foo{
    T tVar;
public:
    Foo(T t) : tVar(t) { }
};
template<class T> class FooDerived:public Foo<T>
{
};
int main()
{
    FooDerived<int> d(5);
    return 0;
}
```
A 代码可以正确通过编译。

B 编译错误，FooDerived是一个继承模板类的非模板类，它的类型不能改变。

C 编译错误，tVal变量是一个不确定的类型。

D 编译错误，可以在FooDerived类中添加一个构造函数解决问题。

```
    这里 FooDerived虽然继承了foo的构造函数，但是应该显示调用一下
```

// 1117 DAY11

- 28.以下函数中，和其他函数不属于一类的是____。（C）   //错误选择了D

A fwrite

B putc

C pwrite

D putchar

E getline

F scanf

```
    把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 
```
- 29.下列哪个用法哪个是错误的(C)    //错误选择了A
A int *a;

B extern const int array[256];

C const int &ra;

D typedef void (*FUN)();

```
        引用必须初始化
```

- 30.在重载一个运算符为成员函数时，其参数表中没有任何参数，这说明该运算符是 （ C）。 //错误选择了A
A 无操作数的运算符

B 二元运算符

C 前缀一元运算符

D 后缀一元运算符

```
    如果重载函数是  A operator++(int)  表示重载后缀++ 即是 a++ 
    如果重载函数是  A operator++()  表示重载前缀++ 即是 ++a 
```

- 31.若PAT是一个类，则程序运行时，语句“PAT(*ad)[3];”调用PAT的构造函数的次数是（C）。  //错误选择了B
A 2

B 3

C 0

D 1

```
    pat (*obj)[3]; 定义三个指向pat类型object的指针，所以构造函数调用次数为0 
    假如改为pat obj[3],则调用3次。 
```

// 1118 DAY12

- 32.代码生成阶段的主要任务是：（C）   //错误选择了B

A 把高级语言翻译成机器语言

B 把高级语言翻译成汇编语言

C 把中间代码变换成依赖具体机器的目标代码

D 把汇编语言翻译成机器语言

```
    源码 ->（扫描）-> 标记 ->（语法分析）-> 语法树 ->（语义分析）-> 标识语义后的语法树 ->（源码优化）-> 中间代码 ->（代码生成）-> 目标机器代码 ->（目标代码优化）-> 最终目标代码
```
- 33.如果有一个类是 myClass , 关于下面代码正确描述的是:(C)   //错误选择了D

```cpp
myClass::~myClass(){
delete this;
this = NULL;
}

```
A 正确，我们避免了内存泄漏

B 它会导致栈溢出

C 无法编译通过

D 这是不正确的，它没有释放任何成员变量。

```
    因为this是Myclass * const this指针，也就是说this指针指向的对象(不是指向的对象的值)不可以改变，
    所以给this赋值在编译期间就不会通过，如果没有这语句的话是栈溢出，因为会不停的调用析构函数。
```

// 1120 DAY13
- 34.以下系统中，int类型占几个字节，指针占几个字节，操作系统可以使用的最大内存空间是多大：（C）  //错误选择了A

A 32位下：4,4,2^32 64位下：8,8,2^64

B 32位下：4,4,不限制 64位下：4,8,不限制

C 32位下：4,4,2^32 64位下：4,8,2^64

D 32位下：4,4,2^32 64位下：4,4,2^64
```
    数据类型是语言定义的关键字，只对编译器可见，所以与操作系统无关
```

- 35.哪个操作符不能被重载?（C）  //错误选择了A

A , (逗号)

B ()

C . (点)

D []

E ->

```
c++中不能重载的运算符：
. (成员访问运算符)
  
*  (成员指针访问运算符)
  
::  (域运算符)
  
sizeof  (长度运算符)
  
?:  (条件运算符）
  
  前两个运算符不能重载是为了保证访问成员的功能不能被改变，域运算符和sizeof 运算符的运算对象是类型而不是变量或一般表达式，不具备重载的特征。
```

// 1121 DAY14
- 36.假设寄存器为8位，用补码形式存储机器数，包括一位符号位，那么十进制数-25在寄存器表示为：(D)  //错误选择了C

A 67H

B 99H

C E6H

D E7H

```
    注意：寄存器存储数据用的是补码
```

- 37.C++中以下关于函数调用的说法哪个是正确的？（D）   //错误选择了B

A 传地址后实参和形参指向不同的对象

B 传引用后实参和形参是不同的对象

C 传值后对形参的修改会改变实参的值

D 其他三项都不对

```
    传地址或者引用时，形参与实参都有相同的地址； 
    传值调用时，只是将数据进行了复制，不会改变实参的值。
```

- 38.下面程序运行后的结果为：(D)  //错误选择了B
```cpp
char str[] = "glad to test something";
char *p = str;
p++;
int *p1 = reinterpret_cast<int *>(p);
p1++;
p = reinterpret_cast<char *>(p1);
printf("result is %s\n", p);
```

A result is glad to test something

B result is ad to test something

C result is test something

D result is to test something

// 1122 DAY15

- 39.关于以下代码，哪个说法是正确的？(B)  //错误选择了D
```cpp
myClass::foo(){
    delete this;
}
..
void func(){
    myClass *a = new myClass();
    a->foo();
}
```
A 它会引起栈溢出

B 都不正确

C 它不能编译

D 它会引起段错误
```
    在类的成员函数delete this是允许的，但在后续的行为里不能涉及this指针的操作，如成员变量，虚函数
    在析构函数里不能调用delete this，从而导致递归调用，导致堆栈溢出。
```

- 40.假定CSomething是一个类，执行下面这些语句之后，内存里创建了____个CSomething对象。(E)   //错误选择了C
```cpp
CSomething a();
CSomething b(2);
CSomething c[3];
CSomething &ra = b;
CSomething d=b;
CSomething *pA = c;
CSomething *p = new CSomething(4);
```
A 10

B 9

C 8

D 7

E 6

F 5

```
    CSomething a()；// 没有创建对象，这里不是使用默认构造函数，而是定义了一个函数

```

- 41.下面这段代码运行时会出现什么问题？(B)       //错误选择了D
```cpp
class A
{
public:
    void f()
    {
    printf("A\n");
    }
};
class B: public A
{
public:
    virtual void f()
        {
            printf("B\n");
        }
};
int main()
{
    A *a = new B;
    a->f();
    delete a;
    return 0;
}
```
A 没有问题，输出B

B 不符合预期的输出A

C 程序不正确

D 以上答案都不正确

```
    因为父类函数f不是虚函数，所以调用时还是调用的A::f(),所以会输出A
    但是也会出现程序崩溃，原因在于，子类多一个指向虚基表的指针，多了四个字节，
    所以子类对象赋给父类时，地址偏移了四个字节，当delete a时，找不到这块内存，从而出现程序崩溃。
```
// 1124 DAY17
- 42. 
```cpp
#include <iostream>
using namespace std;
class A {
public:
    ~A() {
    cout << "~A()";
    }
};
class B{
public:
    virtual ~B() {
        cout << "~B()";
    }
};
class C: public A, public B {
public:
    ~C() {
        cout << "~C()";
    }
};
int main() {
    C * c = new C;
    B * b1 = dynamic_cast<B *>(c);
    A * a2 = dynamic_cast<A *>(b1);
    delete a2;
}
```
则程序输出：(D)   //错误选择了B

A ~C()~B()~A()

B ~C()~A()~B()

C A)B)都有可能

D 以上都不对

// 1125 DAY18

- 43.malloc函数进行内存分配是在什么阶段?（D）   //错误选择了A

A 编译阶段

B 链接阶段

C 装载阶段

D 执行阶段

```

栈内存： 
    用来保存定义在函数内的非static对象。  
    分配在静态内存或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。
```
- 44.下列程序的输出结果,正确的是（C）   //错误选择了A

```cpp
#include <iostream>
using namespace std;
class A
{
public:
    void print()
    {
        cout << "A:print()";
    }
};
class B: private A
{
public:
    void print()
    {
        cout << "B:print()";
    }
};
class C: public B
{
public:
    void print()
    {
        A:: print();
    }
};
int main()
{
    C b;
    b.print();
}
```
A A:print()

B B:print()

C 编译出错

```
    此处Bprivate继承A，所以C继承B之后，无法访问 A:print()
```

// DAY19 1127
- 45.假设你只有100Mb的内存，需要对1Gb的数据进行排序，最合适的算法是？(A)     //错误选择了C

A 归并排序

B 插入排序

C 快速排序

D 冒泡排序
```
    空间不足时，可选择归并排序，一部分排好了，放入文件后，再排另一部分 
```
// DAY20 1128
- 46.若栈采用顺序存储方式存储，现两栈共享空间V[1..m]，top[i]代表第i个栈( i =1,2)栈顶，栈1的底在v[1]，栈2的底在V[m]，则栈满的条件是（ B）。    //错误选择了A

A top[1]+top[2]=m

B top[1]+1=top[2]

C top[2]-top[1]|=0

D top[1]=top[2]

```
    top是栈顶元素的位置（栈顶指针指向的位置有数据）， 于是栈满时，就是top1+1=top2 
```

- 47.某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二叉树中的叶子结点数为（B）   //错误选择了A
A 不存在这样的二叉树

B 200

C 198

D 199
```
    结点数=分支数+1
```

- 48.初始序列为1 8 6 2 5 4 7 3一组数采用堆排序，当建堆（小根堆）完毕时，堆所对应的二叉树中序遍历序列为：（A）   //错误选择了C
A 8 3 2 5 1 6 4 7

B 3 2 8 5 1 4 6 7

C 3 8 2 5 1 6 7 4

D 8 2 3 5 1 4 7 6

```
    二叉堆满足二个特性： 
1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。 
2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。
```

- 48.设无向图的顶点个数为n，则该图最多有多少条边？(C)      //错误选择了A
A n-1

B n（n+1）/2

C n（n-1）/2

D n

E 不同于以上答案

```
    无向图的顶点个数为n,则该图最多有 n(n-1)/2 条边； 
    有相图的顶点个数为n，则该图最多有n(n-1)条边。
    对于无向图，对于任一定点，只有一条边，所以对于n个节点的无向图，边的个数满足满足组合公式C（n,2）
```


