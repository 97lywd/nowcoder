//1106 --- DAY1
- 1.int *p[4] 与选择项中的 说明 （C） 等价    //错误选择了D

A int p[4]

B int *p

C int *(p[4])

D int (*p)[4]

```
    D是数组指针而C与题目都为指针数组
```

- 2.在 c++ 语言中，对函数参数默认值描述正确的是（D）  //错误选择了B

A 函数参数的默认值只能设定一个

B 一个函数的参数若有多个，则参数默认值的设定可以不连续

C 函数参数必须设定默认值

D 在设定了参数的默认值后，该参数后面定义的所有参数都必须设定默认值


```
对于B：参数默认值必须从右向左定义，即在一个指定了默认值的参数的右边，不能出现没有指定默认值的参数。
```

// 1107 --- DAY2

- 3.下面叙述错误的是（D）    //错误选择了C

```cpp
    char acX[] = "abc";
    char acY[] = {'a','b','c'};
    char *szX = "abc";
    char *szY = "abc"; 
```
A acX与acY的内容可以修改

B szX与szY指向同一个地方

C acX占用的内存空间比acY大

D szX内容修改后，szY内容也会被修改

```
    acX与acY所占空间大小是一样的
```

- 4.在32位cpu上选择缺省对齐的情况下，有如下结构体定义：

```c
    struct A{
        unsigned a:19;
        unsigned b:11;
        unsigned c:4;
        unsigned d:29;
        char index;
    };
```
则sizeof(struct A)的值是（C）     //错误选择了D

A 9

B 12

C 16

D 20

- 5.以下关于C++的描述中哪一个是正确的（C）    //错误选择了D

A 任何指针都必须指向一个实例

B 子类指针不可以指向父类实例

C 任何引用都必须指向一个实例

D 引用所指向的实例不可能无效

- 6.关于虚函数描述正确的是（B）  //错误选择了C

A 派生类的虚函数与基类的虚函数具有不同的参数个数和类型

B 内联函数不能是虚函数

C 派生类必须重新定义基类的虚函数

D 虚函数可以是一个static型的函数

```        
    inline是在编译器将函数类容替换到函数调用处，是静态编译的。
    而虚函数是动态调用的，在编译器并不知道需要调用的是父类还是子类的虚函数，
    所以不能够inline声明展开，所以编译器会忽略

    虚函数的调用必须有this指针，而static型函数没有this指针。

```

- 7.关于C++的inline关键字，以下说法正确的是（D）   //错误选择了C

A 使用inline关键字的函数会被编译器在调用处展开

B 头文件中可以包含inline函数的声明

C 可以在同一个项目的不同源文件内定义函数名相同但实现不同的inline函数

D 定义在class声明内的成员函数默认是inline函数

E 优先使用class声明内定义的inline函数

F 优先使用class实现的inline函数的实现

//1108 --- DAY3

- 8.能把函数处理结果的第二个数据返回给主调函数，在下面的方法中不正确的是（A）   //错误选择了D

A return这二个数

B 形参用数组

C 形参用二个指针

D 用二个局部变量

- 9.由多个源文件组成的C程序，经过编辑、预处理、编译、链接阶段会生成最终的可执行程序。下面哪个阶段可以发现被调用的函数未定义？
    C  //错误选择了A

A 预处理

B 编译

C 链接

D 执行

```


链接是将各个编译单元中的变量和函数引用与定义进行绑定，保证程序中的变量和函数都有对应的实体，
若被调用函数未定义，就在此过程中会发现。
编辑阶段创建和修改源程序,预处理阶段分析宏定义以及替换宏引用；编译过程是把源程序翻译为与之等价的目标程序。
```

- 10.下列main()函数执行后的结果为(B)    //错误选择了C
```cpp
    int func()
    {
        int i,j,k = 0;
        for(i = 0; j = -1;j = 0;i++,j++){
            k++;
        }
        return k;
    }
    int main()
    {
        cout << (func());
    }
```
A -1

B 0

C 1

D 2

```
    注意第一次j不满足条件后，函数跳出循环及直接return k；
```
// 1109 --- DAY4

- 11.以下C语言指令：
```c
以下C语言指令：运行结果是什么？（C）   //错误选择了D
int a[5] = {1,3,5,7,9};
int *p = (int *)(&a+1);
printf(“%d,%d”,*(a+1)，*(p-1));
```
A 2，1

B 3，1

C 3，9

D 运行时崩溃

```
    这里&a，取的是整个数组的地址，所以p最终指向数组的下一个位置
```

- 12.以下关于纯虚函数的说法,正确的是(A)     //错误选择了C

A 声明纯虚函数的类不能实例化

B 声明纯虚函数的类成虚基类

C 子类必须实现基类的

D 纯虚函数必须是空函数

```
    纯虚函数在基类中是没有定义的，必须在子类中加以实现
    基类被虚继承才是虚基类 
```

- 13.下列情况中，不会调用拷贝构造函数的是（B） //错误选择了D

A 用一个对象去初始化同一个类的另一个新对象时

B 将类的一个对象赋值给该类的另一个对象时

C 函数的形参对象，调用函数进行形参和实参结合时

D 函数的返回值是类的对象，函数执行返回调用时


```
    对于B选项，要赋值的对象是已经存在的，所以不需要调用拷贝构造函数
```


// 1110 --- DAY5

- 13.下面两个结构体

```c    
struct One{
    double d;
    char c;
    int i;
}
struct Two{
    char c;
    double d;
    int i;
}

```
在#pragma pack(4)和#pragma pack(8)的情况下，结构体的大小分别是(C)    //错误选择了B
A 16 24,16 24
B 16 20,16 20
C 16 16,16 24
D 16 16,24 24

- 14.下面程序的输出结果是(B)       //错误选择了A

```c
#include<iosteam.h>
void main(){
    int n[][3] = {10,20,30,40,50,60};
    int (*p)[3];
    p=n;
    cout<<p[0][0]<<","<<*(p[0]+1)<<","<<(*p)[2]<<endl;
}

```
A 10,30,50

B 10,20,30

C 20,40,60

D 10,30,60


- 15.
```c
int main(){
    int a;float b,c;
    scanf("%2d%3f%4f",&a,&b,&c);
    printf("\na=%d,b=%d,c=%f\n",a,b,c);
}
```
若运行时从键盘上输入9876543210l,则上面程序在gcc编译器下的输出结果是(B)    //错误选择了C

A a=98,b=765,c=4321.000000

B a=98,b=0,c=0.000000

C a=98,b=765.000000,c=4321.000000

D a=98,b=765.0,c=4321.0

- 16.
```c
ClassA *pclassa=new ClassA[5];
delete pclassa;
```
c++语言中，类ClassA的构造函数和析构函数的执行次数分别为(A)      //错误选择了C

A 5,1

B 1,1

C 5,5

D 1,5

```
    这里delete的是指针不是指向的数组
```

// 1111  --- DAY6

- 17.
```c
#include<iostream>
#include<stdio.h>
using namespace std;
int main(){
int m=0123, n = 123;
printf("%o %o\n", m, n);
return 0;
}
```
程序运行后的输出结果是(C)     //错误选择了D

A 0123 0173

B 0123 173

C 123 173

D 173 173

```
    %o 是以八进制输出  所以0123 --- 1*（8 ^ 2） + 2 * 8 + 3 * 1 = 123
```

- 18.关于"深拷贝"，下列说法正确的是(A)   //错误选择了D

A 会拷贝成员数据的值和会拷贝静态分配的成员对象

B 只会拷贝成员数据的值

C 只会拷贝静态分配的成员对象

D 只会拷贝动态分配的成员对象

```
    深拷贝是新建一个对象，把原来对象的数据复制过来。
    但是有一点要注意，对含有静态成员数据的对象，
    静态成员属于类，被所有对象共享，所以深拷贝也不会拷贝这一份数据。只会拷贝非静态成员数据
```


// 1113 DAY7

- 19.有如下类模板定义：（D）   //错误选择了B
```cpp
template<class T> class BigNumber{
    long n;
public:
    BigNumber(T i):n(i){}
    BigNumber operator+(BigNumber b)
        {
            return BigNumber(n+b.n);
        }
};
```
A 3+3

B b1+3

C b1+b2

D 3+b1

- 20. 在int p[][4]={{1},{3,2},{4,5,6},{0}};中，p[1][2]的值是(B)   //错误选择了D
A 1

B 0

C 6

D 2

- 21.下列关于对象数组的描述中，(A)是错误的   //错误选择了C
A 对象数组只能赋初值而不能再赋值

B 对象数组的每个元素是同一个类的对象

C 对象数组的数组名是一个指针常量

D 对象数组的下标是从0开始的

```
    指针常量：强调的是一个指针指向了一个常量，所以地址是不可变的，但是内容是可以修改的，这和数组名相符
```


// 1114 DAY8
- 22.下面关于"指针"的描述不正确的是(A)     //错误选择了D
A 当使用free释放掉一个指针内容后,指针变量的值被置为NULL

B 32位系统下任何类型指针的长度都是4个字节

C 指针的数据类型声明的是指针实际指向内容的数据类型

D 野指针是指向未分配或者已经释放的内存地址

```
    当free释放内存之后，指针还指向原来的那块地址，需要我们设置 p= NULL；
    如果不手动设置p = NULL，此时P就变成了野指针
    野指针：指向一个已删除的对象或未申请访问受限内存区域的指针（如未初始化或者free后没有置为NULL）
```

- 22.假定有类AB，有相应的构造函数定义，能正确执行
语句，请问执行完此语句后共调用该类的构造函数次数为__(A)  //错误选择了D

` AB a(4),b(5),c[3],*p[2]={&a,&b};

A 5

B 4

C 3

D 9

// 1115 DAY9
- 23.当一个类的某个函数被说明为virtual，则在该类的所有派生类中的同原型函数（D）//错误选择了A

A 只有被重新说明时才是虚函数

B 只有被重新说明为virtual时才是虚函数

C 都不是虚函数

D 都是虚函数

```
    派生类继承父类虚函数后，保留其虚函数性质，所以重写时加不加vtrtual关键字，都是虚函数
    但是为了代码规范，一般加virtual
```

// 1116 DAY10

- 24.有如下C++代码：

``` cpp
struct A{
    void foo(){printf("foo");}
    virtual void bar(){printf("bar");}
    A(){bar();}
};
struct B:A{
    void foo(){printf("b_foo");}
    void bar(){printf("b_bar");}
};
那么
A *p=new B;
p->foo();
p->bar();
```
输出为：（A）   //错误选择了B
A barfoob_bar

B foobarb_bar

C barfoob_foo

D foobarb_fpp

```
    这里A调用foo时，foo不是虚函数，所以调用的是A::foo(),而bar不是虚函数,所以调用的是B::bar()
```

- 25.代码可以通过编译吗？如果不能应该如何修改？(D)  //错误选择了A
```cpp
    template<class T> class Foo{
    T tVar;
public:
    Foo(T t) : tVar(t) { }
};
template<class T> class FooDerived:public Foo<T>
{
};
int main()
{
    FooDerived<int> d(5);
    return 0;
}
```
A 代码可以正确通过编译。

B 编译错误，FooDerived是一个继承模板类的非模板类，它的类型不能改变。

C 编译错误，tVal变量是一个不确定的类型。

D 编译错误，可以在FooDerived类中添加一个构造函数解决问题。

```
    这里 FooDerived虽然继承了foo的构造函数，但是应该显示调用一下
```

// 1117 DAY11

- 26.以下函数中，和其他函数不属于一类的是____。（C）   //错误选择了D

A fwrite

B putc

C pwrite

D putchar

E getline

F scanf

```
    把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 
```
- 27.下列哪个用法哪个是错误的(C)    //错误选择了A
A int *a;

B extern const int array[256];

C const int &ra;

D typedef void (*FUN)();

- 28.在重载一个运算符为成员函数时，其参数表中没有任何参数，这说明该运算符是 （ C）。 //错误选择了A
A 无操作数的运算符

B 二元运算符

C 前缀一元运算符

D 后缀一元运算符

- 29.若PAT是一个类，则程序运行时，语句“PAT(*ad)[3];”调用PAT的构造函数的次数是（C）。  //错误选择了B
A 2

B 3

C 0

D 1



// 1118 DAY12

- 30.代码生成阶段的主要任务是：（C）   //错误选择了B

A 把高级语言翻译成机器语言

B 把高级语言翻译成汇编语言

C 把中间代码变换成依赖具体机器的目标代码

D 把汇编语言翻译成机器语言

-31. 如果有一个类是 myClass , 关于下面代码正确描述的是:(C)   //错误选择了D

```cpp
myClass::~myClass(){
delete this;
this = NULL;
}

```
A 正确，我们避免了内存泄漏

B 它会导致栈溢出

C 无法编译通过

D 这是不正确的，它没有释放任何成员变量。



